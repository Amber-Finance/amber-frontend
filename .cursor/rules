# AmberFi Frontend Development Guidelines

## üéØ Core Philosophy

- Write clean, maintainable, and well-documented code
- Prioritize readability and developer experience
- Follow functional programming patterns where possible
- Extract reusable logic into custom hooks
- Keep components focused and composable
- Always use TypeScript for type safety

---

## üìÅ Project Structure & File Organization

### Feature-Based Architecture Philosophy

Our codebase follows a **hybrid feature-based architecture** adapted for Next.js:

- Features are organized by domain (deposit, strategy, swap, portfolio)
- Shared code lives in common areas (components/common, utils/, hooks/)
- Each feature owns its components, hooks, and logic
- Avoid cross-feature dependencies‚Äîextract shared code to common areas
- Keep related code close together for better maintainability

### Folder Structure

```
src/
‚îú‚îÄ‚îÄ api/              # API client functions for data fetching
‚îÇ   ‚îú‚îÄ‚îÄ [domain]/     # Domain-specific API functions (redBank/, swap/)
‚îÇ   ‚îî‚îÄ‚îÄ *.ts          # Shared API utilities
‚îú‚îÄ‚îÄ app/              # Next.js app directory (pages, layouts, metadata)
‚îÇ   ‚îú‚îÄ‚îÄ deposit/      # Deposit feature (page.tsx, components)
‚îÇ   ‚îú‚îÄ‚îÄ strategies/   # Strategies feature
‚îÇ   ‚îú‚îÄ‚îÄ swap/         # Swap feature
‚îÇ   ‚îú‚îÄ‚îÄ portfolio/    # Portfolio feature
‚îÇ   ‚îî‚îÄ‚îÄ layout.tsx    # Root layout
‚îú‚îÄ‚îÄ components/       # React components
‚îÇ   ‚îú‚îÄ‚îÄ common/       # Shared/reusable components (TokenBalance, FormattedValue)
‚îÇ   ‚îú‚îÄ‚îÄ layout/       # Layout components (Navbar, Footer, Hero)
‚îÇ   ‚îú‚îÄ‚îÄ ui/           # Base UI components (Button, Card, Input)
‚îÇ   ‚îú‚îÄ‚îÄ deposit/      # Deposit-specific components
‚îÇ   ‚îú‚îÄ‚îÄ strategy/     # Strategy-specific components
‚îÇ   ‚îú‚îÄ‚îÄ swap/         # Swap-specific components
‚îÇ   ‚îî‚îÄ‚îÄ portfolio/    # Portfolio-specific components
‚îú‚îÄ‚îÄ config/           # Configuration files (chain, tokens, etc.)
‚îú‚îÄ‚îÄ constants/        # Application constants
‚îú‚îÄ‚îÄ hooks/            # Custom React hooks
‚îÇ   ‚îú‚îÄ‚îÄ [domain]/     # Domain-specific hooks (swap/, redBank/)
‚îÇ   ‚îî‚îÄ‚îÄ *.ts          # Shared hooks
‚îú‚îÄ‚îÄ lib/              # Third-party library wrappers
‚îú‚îÄ‚îÄ store/            # Zustand stores for global state
‚îú‚îÄ‚îÄ theme/            # Theme configuration
‚îú‚îÄ‚îÄ types/            # TypeScript type definitions
‚îÇ   ‚îú‚îÄ‚îÄ generated/    # Auto-generated types (CosmWasm contracts)
‚îÇ   ‚îú‚îÄ‚îÄ classes/      # Class definitions
‚îÇ   ‚îî‚îÄ‚îÄ types.d.ts    # Global type definitions
‚îî‚îÄ‚îÄ utils/            # Utility functions
    ‚îî‚îÄ‚îÄ [domain]/     # Domain-specific utilities (health_computer/)
```

### Feature Organization Rules

1. **Feature Boundaries**
   - Each feature (deposit, strategy, swap) should be self-contained
   - Feature components go in `components/[feature]/`
   - Feature-specific hooks go in `hooks/[feature]/` or `hooks/use[Feature]*.ts`
   - Feature pages go in `app/[feature]/`

2. **Shared Code Extraction**

   ```typescript
   // ‚ùå BAD - Importing from another feature
   import { SwapButton } from '@/components/strategy/SwapButton'

   // ‚úÖ GOOD - Extract to common
   import { SwapButton } from '@/components/common/SwapButton'

   // ‚ùå BAD - Duplicating logic across features
   // deposit/DepositForm.tsx and strategy/StrategyForm.tsx both have same validation

   // ‚úÖ GOOD - Extract to shared hook
   import { useFormValidation } from '@/hooks/useFormValidation'
   ```

3. **Domain Models & Types**
   - Centralize domain types in `types/types.d.ts`
   - Create specific type files for complex domains (e.g., `types/strategy.d.ts`)
   - Keep generated types separate in `types/generated/`

4. **API Organization**

   ```
   api/
   ‚îú‚îÄ‚îÄ cosmwasm-client.ts        # Shared client setup
   ‚îú‚îÄ‚îÄ getPortfolioPositions.ts  # Shared API calls
   ‚îú‚îÄ‚îÄ redBank/                  # RedBank domain
   ‚îÇ   ‚îú‚îÄ‚îÄ getDenomData.ts
   ‚îÇ   ‚îú‚îÄ‚îÄ getAssetsApr.ts
   ‚îÇ   ‚îî‚îÄ‚îÄ getAssetsTvl.ts
   ‚îî‚îÄ‚îÄ swap/                     # Swap domain
       ‚îî‚îÄ‚îÄ getNeutronRouteInfo.ts
   ```

5. **Avoid Cross-Feature Imports**

   ```typescript
   // ‚ùå BAD
   // Used in deposit feature - this creates tight coupling
   // ‚úÖ GOOD - Option 1: Make it common if truly shared
   import { Card } from '@/components/common/Card'
   // ‚úÖ GOOD - Option 2: Create feature-specific version if logic differs
   import { DepositCard } from '@/components/deposit/DepositCard'
   import { StrategyCard } from '@/components/strategy/StrategyCard'
   ```

### File Naming Conventions

- **Components**: PascalCase (e.g., `StrategyFormPanel.tsx`, `ConnectButton.tsx`)
- **Hooks**: camelCase with `use` prefix (e.g., `usePortfolioData.ts`, `useSwapState.ts`)
- **Utilities**: camelCase (e.g., `format.ts`, `broadcast.ts`, `errorParsing.ts`)
- **API functions**: camelCase (e.g., `getPortfolioPositions.ts`, `getDenomData.ts`)
- **Types**: PascalCase interfaces in `types.d.ts` or dedicated type files
- **Config**: camelCase (e.g., `chain.ts`, `tokens.ts`)

---

## üì¶ Import Guidelines

### ALWAYS Use Absolute Imports

```typescript
// ‚úÖ CORRECT - Use @ alias for absolute imports
import { useStore } from '@/store/useStore'
import chainConfig from '@/config/chain'
import { formatNumber } from '@/utils/format'
import { Button } from '@/components/ui/Button'
import { usePortfolioData } from '@/hooks/usePortfolioData'

// ‚ùå WRONG - Never use relative imports
import { useStore } from '../../../store/useStore'
import chainConfig from '../../config/chain'
```

### Strict Rule: No Relative Imports Anywhere

- Never import using './' or '../' anywhere in the codebase, including barrel files (`index.ts`).
- Always use the `@/*` alias for all internal imports.
- This applies to components, hooks, utils, api, and re-exports in barrels.

Patterns that are forbidden:

```text
./*
../*
```

Recommended ESLint enforcement:

```js
// eslint.config.mjs
'no-restricted-imports': [
  'error',
  {
    patterns: ['./*', '../*'],
  },
],
```

### Import Order

1. External dependencies (React, Next.js, third-party libraries)
2. Internal absolute imports grouped by type:
   - Components (`@/components/`)
   - Hooks (`@/hooks/`)
   - Utils (`@/utils/`)
   - Store (`@/store/`)
   - Config (`@/config/`)
   - Types (`@/types/`)

```typescript
// Example of proper import order
'use client'

import { useCallback, useEffect, useMemo, useState } from 'react'

import { useRouter } from 'next/navigation'

import { useChain } from '@cosmos-kit/react'
import { BigNumber } from 'bignumber.js'
import { ArrowLeft } from 'lucide-react'

import { StrategyDisplayPanel } from '@/components/strategy/StrategyDisplayPanel'
import { StrategyFormPanel } from '@/components/strategy/StrategyFormPanel'
import { Button } from '@/components/ui/Button'
import chainConfig from '@/config/chain'
import { useDebounceWithStatus } from '@/hooks/useDebounce'
import useHealthComputer from '@/hooks/useHealthComputer'
import { useStore } from '@/store/useStore'
import { calculateUsdValueLegacy } from '@/utils/format'

// Example of proper import order

// Example of proper import order

// Example of proper import order

// Example of proper import order

// Example of proper import order

// Example of proper import order
```

### Export Patterns

- **Named exports** for hooks and utilities: `export function usePortfolioData() {}`
- **Default exports** for components (when single component per file): `export default function ConnectButton() {}`
- **Barrel exports** for related components: Create `index.ts` to re-export

```typescript
// components/deposit/index.ts - Barrel export pattern
export { default as InfoCard } from '@/components/deposit/InfoCard'
export { default as BalanceRow } from '@/components/deposit/BalanceRow'
export { default as MetricRow } from '@/components/deposit/MetricRow'
```

---

## üé£ Data Fetching with useSWR

### Standard useSWR Pattern

```typescript
import useSWR from 'swr'

export function useMarketData(denom: string) {
  const { data, error, isLoading, isValidating, mutate } = useSWR(
    // Key: Use null to prevent fetching, or a unique string/array
    denom ? `market-data-${denom}` : null,

    // Fetcher: Async function to fetch data
    async () => {
      const response = await fetch(`/api/markets/${denom}`)
      return response.json()
    },

    // Options: Configure caching, revalidation, etc.
    {
      refreshInterval: 60000, // Refresh every 60 seconds
      revalidateOnFocus: true, // Revalidate when window regains focus
      revalidateOnMount: true, // Fetch on mount
      revalidateOnReconnect: true, // Revalidate on network reconnect
      dedupingInterval: 5000, // Dedupe requests within 5 seconds
      keepPreviousData: true, // Keep previous data while revalidating
      shouldRetryOnError: true, // Retry on error
      errorRetryCount: 3, // Max retry count
      errorRetryInterval: 10000, // Wait 10s between retries

      // Success callback
      onSuccess: (data) => {
        console.log('Data fetched successfully:', data)
        // Update global state if needed
      },

      // Error callback
      onError: (err) => {
        console.error('Error fetching data:', err)
      },
    },
  )

  return {
    data,
    isLoading,
    isValidating,
    error,
    mutate, // Use for manual revalidation
  }
}
```

### useSWR with Conditional Fetching

```typescript
// Only fetch when address exists (wallet connected)
const swrKey = address ? `portfolio-positions-${address}` : null

const { data, error, isLoading, mutate } = useSWR(
  swrKey,
  async () => await getPortfolioPositions(address!),
  { refreshInterval: 60000 },
)
```

### useSWRImmutable for Static Data

```typescript
import useSWRImmutable from 'swr/immutable'

// For data that doesn't change often (markets config, asset params)
const { data, error, isLoading } = useSWRImmutable('allMarketData', fetchAllMarketData, {
  onSuccess: (data) => {
    // Store in Zustand for global access
    setMarkets(data)
  },
})
```

### Important SWR Rules

1. **Always provide a unique key** - Use template strings with variables: `\`${address}/positions\``
2. **Use `null` key to prevent fetching** - When dependencies aren't ready
3. **Return early if loading** - Check `isLoading` before accessing data
4. **Use `mutate()` for manual refresh** - After mutations or user actions
5. **Handle errors gracefully** - Always check for `error` state
6. **Configure appropriate intervals** - Balance freshness with performance

---

## üè™ State Management with Zustand

### Store Structure

```typescript
import { create } from 'zustand'
import { devtools, persist } from 'zustand/middleware'

interface StoreState {
  // State
  markets: Market[] | null
  hideZeroBalances: boolean
  portfolioPositions: PortfolioPositionsResponse | null

  // Actions
  setMarkets: (markets: Market[] | null) => void
  setHideZeroBalances: (hide: boolean) => void
  updateMarketPrice: (denom: string, priceData: PriceData) => void
  updateMarketMetrics: (denom: string, metrics: MarketDataItem) => void
  resetPositions: () => void
}

export const useStore = create<StoreState>()(
  devtools(
    persist(
      (set, get) => ({
        // Initial state
        markets: null,
        hideZeroBalances: true,
        portfolioPositions: null,

        // Actions - Always use immutable updates
        setMarkets: (markets) => {
          if (!markets) return
          set({ markets })
        },

        updateMarketPrice: (denom, priceData) => {
          set((state) => {
            if (!state.markets) return state

            // Create new array with updated market
            const updatedMarkets = state.markets.map((market) =>
              market.asset.denom === denom ? { ...market, price: priceData } : market,
            )

            return { markets: updatedMarkets }
          })
        },

        resetPositions: () => {
          set({ portfolioPositions: null })
        },
      }),
      {
        name: 'amberfi-storage', // localStorage key
        partialize: (state) => ({
          // Only persist specific fields
          markets: state.markets,
          portfolioPositions: state.portfolioPositions,
        }),
      },
    ),
    { name: 'amberfi-store' }, // Redux DevTools name
  ),
)
```

### Using Zustand in Components

```typescript
import { useStore } from '@/store/useStore'

function MyComponent() {
  // Select only what you need (avoids unnecessary re-renders)
  const markets = useStore((state) => state.markets)
  const updateMarketPrice = useStore((state) => state.updateMarketPrice)

  // Or destructure multiple values
  const { hideZeroBalances, setHideZeroBalances } = useStore()

  // Use in effects or handlers
  useEffect(() => {
    if (markets) {
      // Do something with markets
    }
  }, [markets])
}
```

### Selector Hooks Pattern (Domain Models)

Create dedicated selector hooks to process and access Zustand state. This separates data access from business logic.

```typescript
// hooks/usePortfolioData.ts - Data fetching hook (stores RAW data in Zustand)
export function usePortfolioData() {
  const { portfolioPositions, setPortfolioPositions } = useStore()

  const { data, error, isLoading, mutate } = useSWR(
    address ? `portfolio-${address}` : null,
    () => getPortfolioPositions(address!),
    {
      onSuccess: (data) => setPortfolioPositions(data),
    },
  )

  return { portfolioPositions: data, isLoading, error, mutate }
}

// hooks/useDeposits.ts - Selector hook (processes data from Zustand)
export function useDeposits(): Deposit[] {
  const { portfolioPositions } = useStore()

  return useMemo(() => {
    if (!portfolioPositions?.redbank_deposits) return []

    return portfolioPositions.redbank_deposits.map((deposit) => ({
      denom: deposit.denom,
      amount: deposit.amount,
      // ... process into friendly format
    }))
  }, [portfolioPositions])
}

// hooks/useActiveStrategies.ts - Selector hook (processes data from Zustand)
export function useActiveStrategies(): ActiveStrategy[] {
  const { portfolioPositions } = useStore()

  return useMemo(() => {
    if (!portfolioPositions?.accounts) return []

    return portfolioPositions.accounts.map((account) => ({
      accountId: account.id,
      leverage: calculateLeverage(account),
      // ... process into friendly format
    }))
  }, [portfolioPositions])
}
```

**Benefits of Selector Pattern:**

- ‚úÖ Single source of truth (Zustand stores RAW API data)
- ‚úÖ Computed values are derived consistently
- ‚úÖ Components don't need to know data structure
- ‚úÖ Easy to test selectors independently
- ‚úÖ Avoids data duplication across components

### Zustand Best Practices

1. **Use selectors to minimize re-renders** - Only select what component needs
2. **Keep actions pure** - No side effects in reducers
3. **Use immutable updates** - Always create new objects/arrays
4. **Persist selectively** - Only persist what's needed across sessions
5. **Store RAW data** - Compute derived data in components/hooks via selectors
6. **Reset on logout** - Clear sensitive data when wallet disconnects
7. **Create selector hooks** - Don't process data directly in components

---

## ü™ù Custom Hooks Patterns

### When to Extract a Hook

Extract logic into a custom hook when:

- ‚úÖ Logic is reused in multiple components
- ‚úÖ Component has complex state management (>50 lines)
- ‚úÖ Side effects need to be isolated and tested
- ‚úÖ Business logic should be separated from UI
- ‚úÖ Multiple useState/useEffect calls can be grouped

### Hook Naming Convention

- Prefix with `use`: `usePortfolioData`, `useSwapState`, `useHealthComputer`
- Be descriptive: `useDebounceWithStatus` vs `useDebounce`
- Group related hooks: `useMarkets`, `useMarketData`, `useMarketMetrics`

### Hook Organization & Categories

Organize hooks into clear categories for better maintainability:

```
hooks/
‚îú‚îÄ‚îÄ index.ts                    # Export all hooks (barrel export)
‚îú‚îÄ‚îÄ redBank/                    # Domain-specific: RedBank
‚îÇ   ‚îú‚îÄ‚îÄ useAssetsApr.ts
‚îÇ   ‚îú‚îÄ‚îÄ useAssetsTvl.ts
‚îÇ   ‚îî‚îÄ‚îÄ useDenomData.ts
‚îú‚îÄ‚îÄ swap/                       # Domain-specific: Swap
‚îÇ   ‚îú‚îÄ‚îÄ useSwap.ts
‚îÇ   ‚îú‚îÄ‚îÄ useSwapState.ts
‚îÇ   ‚îú‚îÄ‚îÄ useSwapLogic.ts
‚îÇ   ‚îî‚îÄ‚îÄ useRouteInfo.ts
‚îú‚îÄ‚îÄ usePortfolioData.ts         # Data fetching hooks
‚îú‚îÄ‚îÄ usePrices.ts
‚îú‚îÄ‚îÄ useMarkets.ts
‚îú‚îÄ‚îÄ useWalletBalances.ts
‚îú‚îÄ‚îÄ useDepositState.ts          # State management hooks
‚îú‚îÄ‚îÄ useSwapState.ts
‚îú‚îÄ‚îÄ useStrategyState.ts
‚îú‚îÄ‚îÄ useStrategyCommon.ts        # Business logic hooks
‚îú‚îÄ‚îÄ useStrategyDeployment.ts
‚îú‚îÄ‚îÄ useStrategyCalculations.ts
‚îú‚îÄ‚îÄ useHealthComputer.ts        # Computation hooks
‚îú‚îÄ‚îÄ useSimulatedApy.ts
‚îú‚îÄ‚îÄ useDebounce.ts              # Utility hooks
‚îú‚îÄ‚îÄ useTransactions.ts
‚îî‚îÄ‚îÄ useTokenPreselection.ts
```

**Hook Categories:**

1. **Data Fetching Hooks** - Fetch data via useSWR and store in Zustand

   ```typescript
   // Example: usePortfolioData, useMarkets, usePrices
   export function usePortfolioData() {
     const { data, error, isLoading, mutate } = useSWR(...)
     return { portfolioPositions: data, isLoading, error, mutate }
   }
   ```

2. **Selector Hooks** - Process and select data from Zustand

   ```typescript
   // Example: useDeposits, useActiveStrategies
   export function useDeposits(): Deposit[] {
     const { portfolioPositions } = useStore()
     return useMemo(() => processDeposits(portfolioPositions), [portfolioPositions])
   }
   ```

3. **State Management Hooks** - Complex local state with useReducer

   ```typescript
   // Example: useDepositState, useSwapState, useStrategyState
   export function useDepositState() {
     const [state, dispatch] = useReducer(depositReducer, initialState)
     return { state, actions, computed }
   }
   ```

4. **Business Logic Hooks** - Complex calculations and orchestration

   ```typescript
   // Example: useStrategyCommon, useHealthComputer
   export function useStrategyCommon({ strategy, mode }) {
     // Combines multiple hooks and calculations
     const marketData = useMarketData(strategy, markets)
     const walletData = useWalletData(strategy, balances)
     // ... business logic
     return {
       /* all derived state and helpers */
     }
   }
   ```

5. **Utility Hooks** - Generic reusable hooks
   ```typescript
   // Example: useDebounce, useModal, useTransactions
   export function useDebounce<T>(value: T, delay: number): T {
     // Generic debouncing logic
   }
   ```

**Hook Dependencies:**

```
Data Fetching Hooks (useSWR)
    ‚Üì (stores raw data)
Zustand Store
    ‚Üì (reads data)
Selector Hooks (useMemo)
    ‚Üì (consumes processed data)
Components
```

### Data Fetching Hook Pattern

```typescript
/**
 * Centralized Portfolio Data Hook
 * Fetches portfolio data and stores RAW data in Zustand
 *
 * This is the single source of truth for portfolio data fetching.
 * Components should use selector hooks (useDeposits, useActiveStrategies)
 * to get processed data.
 */
export function usePortfolioData() {
  const { address } = useChain(chainConfig.name)
  const { portfolioPositions, setPortfolioPositions, resetPortfolioPositions } = useStore()

  // Reset when wallet disconnects
  useEffect(() => {
    if (!address) {
      resetPortfolioPositions()
    }
  }, [address, resetPortfolioPositions])

  // SWR key - only fetch when wallet connected
  const swrKey = address ? `portfolio-positions-${address}` : null

  const { data, error, isLoading, isValidating, mutate } = useSWR(
    swrKey,
    async () => {
      const data = await getPortfolioPositions(address!)
      return data || portfolioPositions || null
    },
    {
      refreshInterval: 60000,
      revalidateOnFocus: true,
      onSuccess: (data) => {
        if (data) setPortfolioPositions(data)
      },
    },
  )

  return {
    portfolioPositions: data,
    totalPositions: data?.accounts.length ?? 0,
    isLoading,
    error,
    mutate, // For manual refresh
  }
}
```

### Selector Hook Pattern

```typescript
/**
 * Selector hook to get active strategies from portfolio data
 * Processes raw portfolioPositions into strategy format
 */
export function useActiveStrategies(): ActiveStrategy[] {
  const { portfolioPositions } = useStore()

  return useMemo(() => {
    if (!portfolioPositions?.accounts) return []

    return portfolioPositions.accounts.map((account) => ({
      accountId: account.id,
      leverage: calculateLeverage(account),
      // ... process data
    }))
  }, [portfolioPositions])
}
```

### Complex State Hook with useReducer

```typescript
interface DepositState {
  activeTab: 'deposit' | 'withdraw'
  depositAmount: string
  withdrawAmount: string
  sliderPercentage: number
}

type DepositAction =
  | { type: 'SET_ACTIVE_TAB'; payload: 'deposit' | 'withdraw' }
  | { type: 'SET_DEPOSIT_AMOUNT'; payload: string }
  | { type: 'RESET_STATE' }

const depositReducer = (state: DepositState, action: DepositAction): DepositState => {
  switch (action.type) {
    case 'SET_ACTIVE_TAB':
      return { ...state, activeTab: action.payload }
    case 'SET_DEPOSIT_AMOUNT':
      return { ...state, depositAmount: action.payload }
    case 'RESET_STATE':
      return initialState
    default:
      return state
  }
}

export const useDepositState = () => {
  const [state, dispatch] = useReducer(depositReducer, initialState)

  // Action creators (memoized)
  const actions = {
    setActiveTab: useCallback(
      (tab: 'deposit' | 'withdraw') => dispatch({ type: 'SET_ACTIVE_TAB', payload: tab }),
      [],
    ),
    setDepositAmount: useCallback(
      (amount: string) => dispatch({ type: 'SET_DEPOSIT_AMOUNT', payload: amount }),
      [],
    ),
    resetState: useCallback(() => dispatch({ type: 'RESET_STATE' }), []),
  }

  // Derived state (computed values)
  const computed = {
    currentAmount: state.activeTab === 'deposit' ? state.depositAmount : state.withdrawAmount,
    hasAmount: state.depositAmount !== '' && parseFloat(state.depositAmount) > 0,
  }

  return { state, actions, computed }
}
```

### Performance Optimization Hooks

```typescript
// Debounce with status tracking
export function useDebounceWithStatus<T>(value: T, delay: number) {
  const [debouncedValue, setDebouncedValue] = useState(value)
  const [isDebouncing, setIsDebouncing] = useState(false)

  useEffect(() => {
    setIsDebouncing(true)
    const handler = setTimeout(() => {
      setDebouncedValue(value)
      setIsDebouncing(false)
    }, delay)

    return () => clearTimeout(handler)
  }, [value, delay])

  return { debouncedValue, isDebouncing }
}
```

### Hook Best Practices

1. **Document complex hooks** - Use JSDoc comments
2. **Return objects, not arrays** - Easier to destructure: `{ data, error }` vs `[data, error]`
3. **Group return values logically** - `{ state, actions, computed }`
4. **Use proper dependencies** - Always include all dependencies in useEffect/useCallback
5. **Memoize expensive computations** - Use useMemo for derived data
6. **Handle cleanup** - Return cleanup functions from useEffect
7. **Test hooks independently** - Write unit tests for complex hooks

---

## üß© Component Composition & Splitting

### When to Split Components

Split a component when:

- ‚úÖ Component exceeds 200-300 lines
- ‚úÖ A section has its own state/logic
- ‚úÖ A section is reusable across multiple pages
- ‚úÖ Readability suffers from complexity
- ‚úÖ Testing individual parts becomes difficult

### Component Hierarchy Example

```typescript
// ‚ùå BAD - Everything in one component (500+ lines)
export function DeployStrategy({ strategy }: Props) {
  // Massive component with all logic
  return (
    <div>
      {/* Header */}
      {/* Display Panel */}
      {/* Form Panel */}
      {/* Multiple cards */}
      {/* Complex logic mixed with UI */}
    </div>
  )
}

// ‚úÖ GOOD - Split into focused subcomponents
export function DeployStrategy({ strategy }: Props) {
  const strategyCommon = useStrategyCommon({ strategy, mode: 'deploy' })

  return (
    <div className="container">
      <StrategyHeader
        strategy={strategy}
        onBack={() => router.back()}
      />

      <div className="flex gap-6">
        <StrategyDisplayPanel
          strategy={strategy}
          mode="deploy"
          displayValues={displayValues}
          positionCalcs={positionCalcs}
          {...otherProps}
        />

        <StrategyFormPanel
          strategy={strategy}
          mode="deploy"
          collateralAmount={collateralAmount}
          setCollateralAmount={setCollateralAmount}
          {...otherProps}
        />
      </div>
    </div>
  )
}
```

### Subcomponent Organization

```typescript
// components/strategy/
//   ‚îú‚îÄ‚îÄ DeployStrategy.tsx          // Main orchestrator
//   ‚îú‚îÄ‚îÄ ModifyStrategy.tsx          // Main orchestrator
//   ‚îú‚îÄ‚îÄ StrategyHeader.tsx          // Shared header
//   ‚îú‚îÄ‚îÄ StrategyDisplayPanel.tsx    // Left panel (charts, cards)
//   ‚îú‚îÄ‚îÄ StrategyFormPanel.tsx       // Right panel (inputs, actions)
//   ‚îú‚îÄ‚îÄ StrategyChart.tsx           // Chart component
//   ‚îú‚îÄ‚îÄ StrategyFlowCard.tsx        // Flow visualization card
//   ‚îú‚îÄ‚îÄ MarginCollateralCard.tsx    // Input card
//   ‚îú‚îÄ‚îÄ RiskAssessmentCard.tsx      // Risk info card
//   ‚îî‚îÄ‚îÄ LeverageSlider.tsx          // Slider component

// Each component has clear responsibility and props interface
```

### Component Props Pattern

```typescript
// Define clear, typed interfaces for props
interface StrategyDisplayPanelProps {
  strategy: Strategy
  mode: 'deploy' | 'modify'
  displayValues: DisplayValues
  positionCalcs: PositionCalculations
  marketData: MarketData
  collateralSupplyApy: number
  debtBorrowApy: number
  getEstimatedEarningsUsd: () => string
  healthFactor: number
  currentAmount: number
  multiplier: number
  isLoading?: boolean // Optional props at the end
}

export function StrategyDisplayPanel({
  strategy,
  mode,
  displayValues,
  // ... destructure all props
}: StrategyDisplayPanelProps) {
  // Component implementation
}
```

### Shared Logic Extraction

```typescript
// ‚ùå BAD - Duplicated logic in DeployStrategy and ModifyStrategy
export function DeployStrategy() {
  const [collateralAmount, setCollateralAmount] = useState('')
  const [multiplier, setMultiplier] = useState(2)
  const marketData = useMarketData(strategy, markets)
  const walletData = useWalletData(strategy, balances)
  // 200+ lines of shared logic...
}

export function ModifyStrategy() {
  const [collateralAmount, setCollateralAmount] = useState('')
  const [multiplier, setMultiplier] = useState(2)
  const marketData = useMarketData(strategy, markets)
  const walletData = useWalletData(strategy, balances)
  // 200+ lines of duplicated logic...
}

// ‚úÖ GOOD - Extract shared logic into hook
export function useStrategyCommon({ strategy, mode }: Props) {
  const [collateralAmount, setCollateralAmount] = useState('')
  const [multiplier, setMultiplier] = useState(2)
  const marketData = useMarketData(strategy, markets)
  const walletData = useWalletData(strategy, balances)

  // All shared logic here

  return {
    collateralAmount,
    setCollateralAmount,
    multiplier,
    setMultiplier,
    marketData,
    walletData,
    // ... all shared state and helpers
  }
}

// Now both components are simple:
export function DeployStrategy({ strategy }: Props) {
  const strategyCommon = useStrategyCommon({ strategy, mode: 'deploy' })
  const deployment = useStrategyDeployment(strategyCommon)

  return <StrategyUI {...strategyCommon} {...deployment} />
}
```

### Component Best Practices

1. **One component per file** - Except for small, tightly-coupled helper components
2. **Props over children complexity** - Clear props are better than complex children patterns
3. **Compose from bottom-up** - Build small components, compose into larger ones
4. **Keep render logic simple** - Extract complex JSX into subcomponents
5. **Use loading skeletons** - Show placeholders while data loads
6. **Memoize expensive renders** - Use React.memo for pure components

---

## üé® Styling Guidelines

### Tailwind CSS Usage

```typescript
import { cn } from '@/lib/utils'

// Use cn() utility for conditional classes
<div className={cn(
  'base-classes',
  'more-base-classes',
  condition && 'conditional-class',
  variantClass,
  className  // Allow parent to override
)}>

// Responsive design - mobile first
<div className="text-sm sm:text-base lg:text-lg">

// Dark mode support
<div className="bg-white dark:bg-card">
<p className="text-gray-900 dark:text-white">
```

### Component Variants with CVA

```typescript
import { type VariantProps, cva } from 'class-variance-authority'

const buttonVariants = cva(
  'inline-flex items-center justify-center rounded-md font-medium transition-colors',
  {
    variants: {
      variant: {
        default: 'bg-primary text-white hover:bg-primary/90',
        outline: 'border border-input hover:bg-accent',
        ghost: 'hover:bg-accent hover:text-accent-foreground',
      },
      size: {
        default: 'h-10 px-4 py-2',
        sm: 'h-9 rounded-md px-3',
        lg: 'h-11 rounded-md px-8',
      },
    },
    defaultVariants: {
      variant: 'default',
      size: 'default',
    },
  },
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {}
```

---

## üõ† Utility Functions & Formatting

### Pure Functions

```typescript
// ‚úÖ GOOD - Pure functions with functional approach
export const formatNumber =
  (decimals = 2) =>
  (num: number | string): string => {
    const parsedNum = safeParseNumber()(num)
    return parsedNum.toLocaleString('en-US', {
      minimumFractionDigits: decimals,
      maximumFractionDigits: decimals,
    })
  }

// Higher-order function for composition
export const formatCurrency =
  (decimals = 2) =>
  (num: number | string): string => {
    const formatted = formatNumber(decimals)(num)
    return `$${formatted}`
  }

// Usage
const formatter = formatCurrency(2)
const result = formatter(1234.567) // "$1,234.57"
```

### Backward Compatibility

```typescript
// Provide legacy wrappers for gradual migration
export const formatNumberLegacy = (num: number | string, decimals = 2): string =>
  formatNumber(decimals)(num)

export const formatCurrencyLegacy = (num: number | string, decimals = 2): string =>
  formatCurrency(decimals)(num)
```

### Error-Safe Parsing

```typescript
import { BigNumber } from 'bignumber.js'

export const safeParseNumber =
  (defaultValue = 0) =>
  (value: any): number => {
    if (value === null || value === undefined) return defaultValue
    if (typeof value === 'number' && !isNaN(value)) return value
    if (typeof value === 'string') {
      const parsed = parseFloat(value)
      return isNaN(parsed) ? defaultValue : parsed
    }
    return defaultValue
  }

// Using BigNumber for precise calculations
export const calculateUsdValue =
  (decimals = 6) =>
  (price: string | number) =>
  (amount: string | number): number => {
    if (!amount || !price) return 0

    const parsedAmount = new BigNumber(amount).shiftedBy(-decimals)
    const parsedPrice = new BigNumber(price)

    return parsedAmount.multipliedBy(parsedPrice).toNumber()
  }
```

### Helper Function Patterns

```typescript
// Break complex functions into smaller helpers
const createDefaultMetadata = (isCurrency: boolean, decimals = 6): FormatMetadata => ({
  type: 'standard',
  value: isCurrency ? '0.00' : '0.' + '0'.repeat(decimals),
  prefix: isCurrency ? '$' : '',
})

const extractPrefix = (value: string, isCurrency: boolean) => {
  if (value.startsWith('$')) {
    return { workingValue: value.substring(1), prefix: '$', isCurrency: true }
  }
  return { workingValue: value, prefix: isCurrency ? '$' : '', isCurrency }
}

// Main function composes helpers
export const formatValue = (value: string | number, options = {}): FormatMetadata => {
  if (!value && value !== 0) return createDefaultMetadata(options.isCurrency)

  const { workingValue, prefix, isCurrency } = extractPrefix(value.toString(), options.isCurrency)

  // ... rest of logic using helpers
}
```

---

## ‚ö†Ô∏è Error Handling

### API Error Handling

```typescript
export default async function getPortfolioPositions(
  address: string,
): Promise<PortfolioPositionsResponse | null> {
  // Early validation
  if (!address) {
    console.warn('Address is required for portfolio positions')
    return null
  }

  try {
    const url = getUrl(chainConfig.endpoints.redBank, `/account_portfolio?address=${address}`)
    const response = await fetchWithTimeout(url, FETCH_TIMEOUT)

    if (!response.ok) {
      console.warn(`Failed to fetch: ${response.status} ${response.statusText}`)
      return null
    }

    const data: PortfolioPositionsResponse = await response.json()
    return data
  } catch (error) {
    console.error('Error fetching portfolio positions:', error)
    return null // Return null, not throw - let UI handle gracefully
  }
}
```

### User-Friendly Error Messages

```typescript
// utils/errorParsing.ts - Parse blockchain errors into friendly messages
export function parseErrorMessage(errorMessage: string): string {
  // Health Factor / LTV errors
  if (errorMessage.includes('exceeding maximum allowed loan-to-value')) {
    return `‚ö†Ô∏è Leverage too high! Your position would exceed the maximum allowed loan-to-value ratio. Please reduce the leverage amount.`
  }

  // Insufficient liquidity
  if (errorMessage.includes('insufficient liquidity')) {
    return `üíß Insufficient liquidity available. Please reduce the amount or try again later.`
  }

  // Wallet issues
  if (errorMessage.includes('wallet not connected')) {
    return `üëõ Wallet connection issue. Please reconnect your wallet and try again.`
  }

  // Generic cleanup
  return cleanGenericError(errorMessage)
}
```

### Transaction Error Handling

```typescript
export function useBroadcast() {
  const executeTransaction = async (
    config: TransactionConfig,
    customMessages?: ToastMessages,
  ): Promise<TransactionResult> => {
    if (!address || !isWalletConnected) {
      toast.error('Wallet not connected')
      return { success: false, error: 'Wallet not connected' }
    }

    const pendingToastId = toast.loading('Transaction pending...', { autoClose: false })

    try {
      const result = await executor()

      toast.update(pendingToastId, {
        render: 'Transaction successful!',
        type: 'success',
        isLoading: false,
        autoClose: 4000,
      })

      await refreshData(config)
      track('transaction_success')

      return { success: true, result }
    } catch (error) {
      console.error('Transaction error:', error)
      const userFriendlyMessage = parseErrorMessage(error.message)

      toast.update(pendingToastId, {
        render: userFriendlyMessage,
        type: 'error',
        isLoading: false,
        autoClose: 4000,
      })

      track('transaction_failed', { error: error.message })
      return { success: false, error: error.message }
    }
  }

  return { executeTransaction }
}
```

### RPC Fallback Pattern

```typescript
const getClientWithFallback = async (primaryRpc: string, fallbackRpcs: string[] = []) => {
  const allRpcs = [primaryRpc, ...fallbackRpcs]

  for (const rpc of allRpcs) {
    try {
      return await getClient(rpc)
    } catch (error) {
      console.warn(`Failed to connect to RPC ${rpc}:`, error)

      if (rpc === allRpcs[allRpcs.length - 1]) {
        throw new Error(`Failed to connect to any RPC endpoint`)
      }
      // Continue to next RPC
    }
  }
}
```

---

## üìù TypeScript Best Practices

### Interface Definitions

```typescript
// Define clear interfaces for all data structures
interface Strategy {
  id: string
  name: string
  collateralAsset: Asset
  debtAsset: Asset
  isCorrelated: boolean
  riskLevel: 'low' | 'medium' | 'high'
  liquidityDisplay: string
}

interface Asset {
  denom: string
  symbol: string
  name: string
  decimals: number
  brandColor?: string
}

// Props interfaces
interface StrategyCardProps {
  strategy: Strategy
  onClick?: () => void
  className?: string
}

// API Response types
interface PortfolioPositionsResponse {
  accounts: Account[]
  redbank_deposits: RedbankDeposit[]
  total_borrows: string
  total_supplies: string
}
```

### Type vs Interface

```typescript
// Use interface for object shapes (preferred)
interface User {
  id: string
  name: string
}

// Use type for unions, intersections, primitives
type Status = 'idle' | 'loading' | 'success' | 'error'
type ID = string | number
type UserWithRole = User & { role: string }
```

### Generic Types

```typescript
// Generic hook types
export function useDebounce<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value)
  // ...
  return debouncedValue
}

// Generic utility types
export const createFetcher =
  <T>(url: string) =>
  async (): Promise<T> => {
    const response = await fetch(url)
    return response.json()
  }
```

### Avoid Any

```typescript
// ‚ùå BAD
function processData(data: any) {
  return data.value
}

// ‚úÖ GOOD
function processData(data: unknown) {
  if (typeof data === 'object' && data !== null && 'value' in data) {
    return data.value
  }
  throw new Error('Invalid data structure')
}

// ‚úÖ BETTER - Define proper types
interface DataWithValue {
  value: string
}

function processData(data: DataWithValue) {
  return data.value
}
```

### Function Complexity Limits

- **Cyclomatic complexity**: target ‚â§ **10**. If a function exceeds 10, split it into smaller helpers. Absolute maximum **15** with a clear rationale and tests.
- **Function length**: target ‚â§ **50** lines; refactor if > **80** lines. Prefer extracting helpers or hooks.
- **Nesting depth**: keep ‚â§ **2** levels. Use guard clauses and early returns to flatten control flow.
- **Parameters**: keep ‚â§ **5**. Prefer a single options object for many parameters.
- **Side effects**: keep pure by default. Isolate I/O and effects behind small, focused functions/hooks.

---

## ‚ö° Performance Optimization

### Memoization

```typescript
// useMemo for expensive computations
const sortedMarkets = useMemo(() => {
  if (!markets) return []
  return markets.sort((a, b) => b.tvl - a.tvl)
}, [markets])

// useCallback for function references
const handleDeposit = useCallback(async () => {
  await executeDeposit(amount, denom)
}, [amount, denom])

// React.memo for pure components
export const StrategyCard = React.memo(({ strategy, onClick }: Props) => {
  return <div onClick={onClick}>{strategy.name}</div>
}, (prevProps, nextProps) => {
  // Custom comparison
  return prevProps.strategy.id === nextProps.strategy.id
})
```

### Debouncing User Input

```typescript
// Always debounce user input before calculations
const [collateralAmount, setCollateralAmount] = useState('')
const [multiplier, setMultiplier] = useState(2)

// Debounce with status tracking
const { debouncedValue: debouncedAmount, isDebouncing: isAmountDebouncing } = useDebounceWithStatus(
  collateralAmount,
  2000,
)

const { debouncedValue: debouncedMultiplier, isDebouncing: isMultiplierDebouncing } =
  useDebounceWithStatus(multiplier, 2000)

const isCalculatingPositions = isAmountDebouncing || isMultiplierDebouncing

// Use debounced values for expensive calculations
const positionCalcs = usePositionCalculations(debouncedAmount, debouncedMultiplier, marketData)
```

### Lazy Loading

```typescript
// Lazy load heavy components
const HeavyChart = lazy(() => import('@/components/charts/HeavyChart'))

function Dashboard() {
  return (
    <Suspense fallback={<ChartSkeleton />}>
      <HeavyChart data={data} />
    </Suspense>
  )
}
```

### Conditional Rendering

```typescript
// Return early to prevent unnecessary renders
if (isLoading) {
  return <LoadingSkeleton />
}

if (error) {
  return <ErrorMessage error={error} />
}

if (!data) {
  return <EmptyState />
}

// Main render
return <DataDisplay data={data} />
```

---

## üß™ Testing & Code Quality

### Testing Strategy

Our testing strategy focuses on critical business logic and user flows:

1. **What to Test (Priority Order)**
   - ‚úÖ **Utility functions** - Pure functions in `utils/`
   - ‚úÖ **Business logic hooks** - Complex calculations (`useStrategyCalculations`, `useHealthComputer`)
   - ‚úÖ **State management** - Reducer logic (`useDepositState`, `useSwapState`)
   - ‚úÖ **API functions** - Data fetching and parsing
   - ‚ö†Ô∏è **Components** - Only for complex business logic components
   - ‚ö†Ô∏è **UI components** - Visual regression tests (optional)

2. **Testing File Organization**

   ```
   src/
   ‚îú‚îÄ‚îÄ utils/
   ‚îÇ   ‚îú‚îÄ‚îÄ format.ts
   ‚îÇ   ‚îî‚îÄ‚îÄ format.test.ts           # Co-locate tests with source
   ‚îú‚îÄ‚îÄ hooks/
   ‚îÇ   ‚îú‚îÄ‚îÄ useStrategyCalculations.ts
   ‚îÇ   ‚îî‚îÄ‚îÄ useStrategyCalculations.test.ts
   ‚îî‚îÄ‚îÄ components/
       ‚îî‚îÄ‚îÄ strategy/
           ‚îú‚îÄ‚îÄ StrategyCard.tsx
           ‚îî‚îÄ‚îÄ StrategyCard.test.tsx
   ```

3. **Testing Patterns**

   ```typescript
   // Testing utility functions
   // Testing hooks with React Testing Library
   import { renderHook } from '@testing-library/react'

   import { formatCurrency, formatNumber } from './format'
   import { useDepositState } from './useDepositState'

   describe('formatNumber', () => {
     it('formats numbers with correct decimals', () => {
       expect(formatNumber(2)(1234.567)).toBe('1,234.57')
     })

     it('handles edge cases', () => {
       expect(formatNumber(2)(0)).toBe('0.00')
       expect(formatNumber(2)(null)).toBe('0.00')
     })
   })

   describe('useDepositState', () => {
     it('initializes with default state', () => {
       const { result } = renderHook(() => useDepositState())
       expect(result.current.state.activeTab).toBe('deposit')
     })

     it('updates amount correctly', () => {
       const { result } = renderHook(() => useDepositState())
       act(() => {
         result.current.actions.setDepositAmount('100')
       })
       expect(result.current.state.depositAmount).toBe('100')
     })
   })
   ```

4. **Testing Guidelines**
   - Write tests for critical calculation logic
   - Test edge cases and error conditions
   - Keep tests focused and readable
   - Use descriptive test names
   - Mock external dependencies (API calls, blockchain queries)
   - Don't test implementation details

### Code Review Checklist

Before requesting review or merging:

**Architecture & Organization**

- [ ] No cross-feature imports (features don't import from each other)
- [ ] Shared code extracted to `components/common/` or `utils/`
- [ ] Domain-specific code in proper folders (`hooks/swap/`, `api/redBank/`)
- [ ] Related code is co-located (hooks near components that use them)

**Code Quality**

- [ ] All imports use `@/` absolute paths (no `../` relative imports)
- [ ] Components are under 300 lines (split if larger)
- [ ] Hooks are under 200 lines (extract sub-hooks if larger)
- [ ] No duplicated logic (extract to shared functions/hooks)
- [ ] Proper TypeScript types (no `any`)

**Data Management**

- [ ] useSWR hooks follow standard patterns
- [ ] Zustand stores RAW data, computed in selectors
- [ ] Expensive computations are memoized
- [ ] User input is debounced before calculations
- [ ] Data flows: API ‚Üí useSWR ‚Üí Zustand ‚Üí Selectors ‚Üí Components

**Error Handling**

- [ ] API errors return null/fallback (don't throw)
- [ ] User-friendly error messages (parsed from blockchain errors)
- [ ] Loading states are handled
- [ ] Empty states are handled

**Performance**

- [ ] useMemo for expensive computations
- [ ] useCallback for function references
- [ ] Debouncing for user input (2000ms)
- [ ] Proper dependency arrays in useEffect/useMemo/useCallback

**Documentation**

- [ ] Complex functions have JSDoc comments
- [ ] Non-obvious logic has inline comments
- [ ] README updated if architecture changes

---

## üìã Documentation Standards

### JSDoc Comments

```typescript
/**
 * Centralized Portfolio Data Hook
 * Fetches portfolio data and stores RAW data in Zustand
 *
 * This is the single source of truth for portfolio data fetching.
 * Components should use selector hooks (useDeposits, useActiveStrategies)
 * to get processed data.
 *
 * @returns {Object} Portfolio data and loading states
 * @returns {PortfolioPositionsResponse | null} portfolioPositions - Raw portfolio data
 * @returns {number} totalPositions - Total number of positions
 * @returns {boolean} isLoading - Loading state
 * @returns {Error | null} error - Error if fetch failed
 * @returns {Function} mutate - Manual revalidation function
 *
 * @example
 * const { portfolioPositions, totalPositions, isLoading, mutate } = usePortfolioData()
 *
 * // Manually refresh data
 * mutate()
 */
export function usePortfolioData() {
  // Implementation
}
```

### Function Documentation

```typescript
/**
 * Fetches portfolio positions for a given wallet address
 *
 * @param address - The wallet address
 * @param chain - The blockchain chain (default: 'neutron')
 * @returns Portfolio positions data including accounts, redbank deposits, and totals
 * @throws {Error} Never throws - returns null on error
 *
 * @example
 * const positions = await getPortfolioPositions('neutron1abc...')
 * if (positions) {
 *   console.log(positions.total_supplies)
 * }
 */
export default async function getPortfolioPositions(
  address: string,
  chain: string = 'neutron',
): Promise<PortfolioPositionsResponse | null> {
  // Implementation
}
```

### Component Documentation

```typescript
/**
 * StrategyFormPanel Component
 *
 * Displays the form panel for deploying or modifying a strategy.
 * Handles user inputs, leverage slider, and action buttons.
 *
 * Features:
 * - Dynamic leverage slider based on LTV and liquidity limits
 * - Real-time position calculations with debouncing
 * - Slippage configuration
 * - Loading skeletons during data fetch
 *
 * @component
 * @example
 * <StrategyFormPanel
 *   strategy={strategy}
 *   mode="deploy"
 *   collateralAmount={amount}
 *   setCollateralAmount={setAmount}
 *   multiplier={multiplier}
 *   setMultiplier={setMultiplier}
 *   onDeploy={handleDeploy}
 *   {...otherProps}
 * />
 */
export function StrategyFormPanel({ ... }: StrategyFormPanelProps) {
  // Implementation
}
```

---

## üöÄ Code Quality Checklist

### Before Committing

- [ ] All imports use `@/` absolute paths (no relative imports like `../`)
- [ ] Components are properly split (no files > 300 lines)
- [ ] Shared logic extracted into custom hooks
- [ ] useSWR hooks follow standard patterns with proper keys and options
- [ ] Zustand mutations are immutable
- [ ] All expensive computations are memoized
- [ ] User input is properly debounced
- [ ] Error handling is user-friendly
- [ ] TypeScript types are properly defined (no `any`)
- [ ] Functions are documented with JSDoc
- [ ] Loading states and error states are handled
- [ ] Dark mode is supported
- [ ] Mobile responsiveness is considered

### Code Review Questions

1. Can this component be split into smaller pieces?
2. Is this logic reused elsewhere? ‚Üí Extract into hook
3. Are we using relative imports? ‚Üí Change to absolute
4. Is this data fetched elsewhere? ‚Üí Use existing hook
5. Are expensive calculations memoized?
6. Is user input debounced?
7. Are errors handled gracefully?
8. Is the loading state clear to users?

---

## üìö Common Patterns Reference

### Pattern: Data Fetching + Global State

```typescript
// 1. Create API function
// api/getMarkets.ts
export async function getMarkets(): Promise<Market[]> {
  const response = await fetch('/api/markets')
  return response.json()
}

// 2. Create useSWR hook
// hooks/useMarkets.ts
export function useMarkets() {
  const { setMarkets } = useStore()

  const { data, error, isLoading } = useSWR('markets', getMarkets, {
    refreshInterval: 60000,
    onSuccess: (data) => setMarkets(data),
  })

  return { markets: data, error, isLoading }
}

// 3. Use in component
function Component() {
  const { markets, isLoading } = useMarkets()
  // Component logic
}
```

### Pattern: Complex Form State

```typescript
// 1. Define state and actions
interface FormState {
  amount: string
  slippage: number
  isProcessing: boolean
}

// 2. Create reducer
const formReducer = (state: FormState, action: FormAction): FormState => {
  switch (action.type) {
    case 'SET_AMOUNT':
      return { ...state, amount: action.payload }
    // ... more cases
  }
}

// 3. Create hook with actions and computed values
export function useFormState() {
  const [state, dispatch] = useReducer(formReducer, initialState)

  const actions = {
    setAmount: useCallback(
      (amount: string) => dispatch({ type: 'SET_AMOUNT', payload: amount }),
      [],
    ),
  }

  const computed = {
    hasValidAmount: state.amount !== '' && parseFloat(state.amount) > 0,
  }

  return { state, actions, computed }
}
```

### Pattern: Responsive Component Composition

```typescript
export function FeaturePage() {
  return (
    <div className="container mx-auto px-4 py-8">
      <PageHeader title="Feature" />

      <div className="flex flex-col lg:flex-row gap-6">
        {/* Left Panel - Display */}
        <DisplayPanel className="flex-1 order-2 lg:order-1" />

        {/* Right Panel - Form */}
        <FormPanel className="flex-1 order-1 lg:order-2" />
      </div>
    </div>
  )
}
```

---

## üéì Learning Resources

### Key Concepts to Master

1. **React Hooks** - useState, useEffect, useMemo, useCallback, useReducer
2. **SWR** - Data fetching, caching, revalidation
3. **Zustand** - Global state management
4. **TypeScript** - Interfaces, generics, type guards
5. **Functional Programming** - Pure functions, composition, immutability
6. **Performance** - Memoization, debouncing, lazy loading

### Recommended Reading

- SWR Documentation: https://swr.vercel.app/
- Zustand Documentation: https://docs.pmnd.rs/zustand/
- React Performance: https://react.dev/learn/render-and-commit
- TypeScript Handbook: https://www.typescriptlang.org/docs/handbook/

---

## ‚ö†Ô∏è Common Anti-Patterns to Avoid

### Anti-Pattern 1: Cross-Feature Dependencies

```typescript
// ‚ùå BAD - Strategy feature importing from Swap feature
// File: components/strategy/StrategyForm.tsx
import { SwapSettingsCard } from '@/components/swap/SwapSettingsCard'

// ‚úÖ GOOD - Extract to common or duplicate if logic differs
// File: components/common/SwapSettingsCard.tsx
export function SwapSettingsCard({ slippage, onSlippageChange }) {
  // Shared implementation
}

// File: components/strategy/StrategyForm.tsx
import { SwapSettingsCard } from '@/components/common/SwapSettingsCard'
```

### Anti-Pattern 2: Processing Data in Components

```typescript
// ‚ùå BAD - Complex data processing in component
function PortfolioPage() {
  const { portfolioPositions } = useStore()

  const activeStrategies = portfolioPositions?.accounts.map((account) => {
    const collateralValue = calculateValue(account.collateral)
    const debtValue = calculateValue(account.debt)
    const leverage = collateralValue / (collateralValue - debtValue)
    // 50 more lines of processing...
    return { ...processed data }
  })

  return <div>{/* render */}</div>
}

// ‚úÖ GOOD - Extract to selector hook
function PortfolioPage() {
  const activeStrategies = useActiveStrategies()  // Clean, testable
  return <div>{/* render */}</div>
}

// hooks/useActiveStrategies.ts
export function useActiveStrategies(): ActiveStrategy[] {
  const { portfolioPositions } = useStore()
  return useMemo(() => processStrategies(portfolioPositions), [portfolioPositions])
}
```

### Anti-Pattern 3: Relative Imports

```typescript
// ‚ùå BAD - Relative imports
import { useStore } from '../../../store/useStore'
import { formatNumber } from '../../utils/format'
import { Button } from '../ui/Button'

// ‚úÖ GOOD - Absolute imports with @ alias
import { useStore } from '@/store/useStore'
import { formatNumber } from '@/utils/format'
import { Button } from '@/components/ui/Button'
```

### Anti-Pattern 4: Monolithic Components

```typescript
// ‚ùå BAD - 800-line component doing everything
export function StrategyPage() {
  // 100 lines of state
  // 200 lines of effects
  // 300 lines of handlers
  // 200 lines of JSX
  return (
    <div>
      {/* Everything inline */}
    </div>
  )
}

// ‚úÖ GOOD - Split into focused components
export function StrategyPage() {
  const strategy = useStrategyCommon({ strategy, mode: 'deploy' })

  return (
    <div>
      <StrategyHeader {...headerProps} />
      <StrategyDisplayPanel {...displayProps} />
      <StrategyFormPanel {...formProps} />
    </div>
  )
}
```

### Anti-Pattern 5: Not Debouncing User Input

```typescript
// ‚ùå BAD - Expensive calculation on every keystroke
function DepositForm() {
  const [amount, setAmount] = useState('')

  // Runs on EVERY character typed! ‚ö†Ô∏è
  const apy = calculateComplexApy(amount, markets, prices)

  return <input value={amount} onChange={(e) => setAmount(e.target.value)} />
}

// ‚úÖ GOOD - Debounce before expensive calculations
function DepositForm() {
  const [amount, setAmount] = useState('')
  const { debouncedValue: debouncedAmount } = useDebounceWithStatus(amount, 2000)

  // Only runs 2 seconds after user stops typing ‚úÖ
  const apy = calculateComplexApy(debouncedAmount, markets, prices)

  return <input value={amount} onChange={(e) => setAmount(e.target.value)} />
}
```

### Anti-Pattern 6: Multiple Sources of Truth

```typescript
// ‚ùå BAD - Data duplicated in multiple places
function Component() {
  const { portfolioPositions } = useStore()  // Source 1
  const [deposits, setDeposits] = useState([])  // Source 2 - duplicate!

  useEffect(() => {
    setDeposits(portfolioPositions?.redbank_deposits || [])
  }, [portfolioPositions])
  // Now we have TWO sources of truth that can get out of sync!
}

// ‚úÖ GOOD - Single source of truth with derived data
function Component() {
  const deposits = useDeposits()  // Derives from single source (Zustand)
  // Only ONE source of truth ‚úÖ
}
```

### Anti-Pattern 7: Throwing Errors in API Functions

```typescript
// ‚ùå BAD - Throwing errors breaks component rendering
export async function getMarkets(): Promise<Market[]> {
  const response = await fetch('/api/markets')
  if (!response.ok) throw new Error('Failed to fetch')  // üí• Breaks UI!
  return response.json()
}

// ‚úÖ GOOD - Return null/fallback value
export async function getMarkets(): Promise<Market[] | null> {
  try {
    const response = await fetch('/api/markets')
    if (!response.ok) {
      console.warn('Failed to fetch markets:', response.statusText)
      return null  // Graceful failure ‚úÖ
    }
    return response.json()
  } catch (error) {
    console.error('Error fetching markets:', error)
    return null  // UI can handle null gracefully
  }
}
```

### Anti-Pattern 8: Using `any` Type

```typescript
// ‚ùå BAD - any defeats TypeScript's purpose
function processData(data: any) {
  return data.value.nested.property  // No type safety! üí•
}

// ‚úÖ GOOD - Proper types
interface DataStructure {
  value: {
    nested: {
      property: string
    }
  }
}

function processData(data: DataStructure) {
  return data.value.nested.property  // Type-safe! ‚úÖ
}

// ‚úÖ ALSO GOOD - Use unknown for truly unknown data
function processData(data: unknown) {
  if (typeof data === 'object' && data !== null && 'value' in data) {
    return (data as DataStructure).value
  }
  throw new Error('Invalid data structure')
}
```

---

## üí° Final Tips

1. **Consistency is key** - Follow these patterns throughout the codebase
2. **When in doubt, extract** - If logic is complex, create a hook or utility
3. **Read existing code** - Learn from well-written components in the codebase
4. **Avoid cross-feature imports** - Extract shared code to common areas
5. **Single source of truth** - Store RAW data once, derive everywhere
6. **Ask questions** - Discuss architectural decisions with the team
7. **Refactor incrementally** - Improve code quality in small steps
8. **Test critical logic** - Focus on business logic, calculations, and state management
9. **Think about the next developer** - Write code that's easy to understand and maintain
10. **Performance matters** - Memoize, debounce, and optimize strategically

### Quick Decision Tree

**"Where should this code go?"**

```
Is it used by multiple features?
‚îú‚îÄ Yes ‚Üí components/common/ or hooks/ or utils/
‚îî‚îÄ No ‚Üí Is it specific to a domain?
    ‚îú‚îÄ Yes ‚Üí components/[feature]/ or hooks/[feature]/
    ‚îî‚îÄ No ‚Üí Keep near where it's used
```

**"Should I extract this to a hook?"**

```
Is the logic used in multiple components? ‚Üí Yes, extract
Is the component over 200-300 lines? ‚Üí Yes, extract
Does it have complex state management? ‚Üí Yes, extract
Is it business logic mixed with UI? ‚Üí Yes, extract
Otherwise ‚Üí Keep it in the component
```

**"Where should this go in Zustand vs Component State?"**

```
Global/shared across features? ‚Üí Zustand
Persists across navigation? ‚Üí Zustand
Single component local state? ‚Üí useState
Complex local state? ‚Üí useReducer + custom hook
Form state? ‚Üí useReducer + custom hook
```

---

**Remember**: Clean code is not about being clever‚Äîit's about being clear, maintainable, and easy to understand. Write code that your future self will thank you for! üöÄ
